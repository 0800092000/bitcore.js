#!/usr/bin/env node

'use strict';

const program = require('../ts_build/program');
const { Wallet } = require('../ts_build/wallet');
const promptly = require('promptly');
const https = require('https');
const ethers = require('ethers');
const utils = require('web3-utils');

program
  .version(require('../package.json').version)
  .option('--name <name>', 'REQUIRED - Wallet Name')
  .option('--txid [txid]', 'REQUIRED (or provide raw tx) - string transaction id')
  .option('--rawtx [rawtx]', 'REQUIRED (or provide tx id) - string raw transaction')
  //.option('--satsPerByte [satsPerByte]', 'optional (defaults to current market rate) for use with UTXO chains - number satsPerByte (in btc/ltc/doge)')
  .option(
    '--gwei [gwei]',
    'optional  (defaults to current market rate) for use with EVM based chains - number gwei (in eth/matic)'
  )
  .option('--path [path]', 'optional - Custom wallet storage path')
  .option('--storageType [storageType]', 'optional - name of the database to use (default Level)')
  .parse(process.argv);

const main = async () => {
  const { name, path, storageType, txid, rawtx, satsPerByte, gwei } = program;
  let wallet;

  try {
    wallet = await Wallet.loadWallet({ name, path, storageType });

    // if (satsPerByte) {
    //   throw new Error('Not yet implemented.');
    // }

    let existingTx;
    if (txid) {
      existingTx = JSON.parse(await wallet.getTransactionByTxid({ txid }));
      // need to parse more... somehow
    } else if (rawtx) {
      existingTx = ethers.utils.parseTransaction(rawtx);
    } else {
      throw new Error('Must provide either a raw transaction or transaction id.');
    }

    const existingGasPriceInWei = Number(existingTx.gasPrice);
    let newFeeInWei;
    if (gwei) {
      newFeeInWei = Number(gwei) * 1000000000;
      if (newFeeInWei <= existingGasPriceInWei) {
        throw new Error(
          `Provided gwei is not greater than existing tx gwei. Existing Tx Gwei: ${existingGasPriceInWei / 1000000000}`
        );
      }
      existingTx.gasPrice = ethers.BigNumber.from(newFeeInWei);
    } else {
      newFeeInWei = JSON.parse(await wallet.getNetworkFee()).feerate;
      existingTx.gasPrice = ethers.BigNumber.from(newFeeInWei);
    }

    console.log(
      `Bumping gas price from ${existingGasPriceInWei / 1000000000} GWei to ${newFeeInWei / 1000000000} GWei`
    );

    const { nonce, gasLimit, gasPrice, to, data, value, chainId } = existingTx;

    const tx = ethers.utils.serializeTransaction({
      nonce,
      gasLimit,
      gasPrice,
      to,
      data,
      value,
      chainId
    });
    console.log('unsignedRawTx: ', tx);
    const passphrase = await promptly.password('Wallet Password:');
    wallet = await wallet.unlock(passphrase);
    const signedTx = await wallet.signTx({ tx, passphrase });
    console.log('signedRawTx: ', signedTx);
    const confirmed = await promptly.confirm('broadcast? (y/n)');
    if (!confirmed) {
      return;
    }
    const transaction = await wallet.broadcast({ tx: signedTx, ignoreNonce: true });
    console.log('txid: ', transaction.txid);
    console.log('Transaction broadcasted');
  } catch (e) {
    console.error(e);
  }
};

main();
