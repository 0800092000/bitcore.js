#!/usr/bin/env node

'use strict';

const program = require('../ts_build/program');
const { Wallet } = require('../ts_build/wallet');
const promptly = require('promptly');
const https = require('https');
const ethers = require('ethers');

program
  .version(require('../package.json').version)
  .option('--name <name>', 'REQUIRED - Wallet Name')
  .option('--txid <txid>', 'REQUIRED (or provide raw tx) - string transaction id')
  //.option('--rawtx <rawtx>', 'REQUIRED (or provide tx id) - string raw transaction')
  .option('--satsPerByte [satsPerByte]', 'optional (defaults to current market rate) for use with UTXO chains - number satsPerByte (in btc/ltc/doge)')
  .option('--gwei [gwei]', 'optional  (defaults to current market rate) for use with EVM based chains - number gwei (in eth/matic)')
  .option('--path [path]', 'optional - Custom wallet storage path')
  .option('--storageType [storageType]', 'optional - name of the database to use (default Level)')
  .parse(process.argv);

const main = async () => {
  const { name, path, storageType, txid, rawtx, satsPerByte, gwei } = program;
  let wallet;
  let data;
  try {
    data = await getCurrencies();
  } catch (err) {
    console.error(err);
  }
  const currencies = JSON.parse(data);
  try {
    wallet = await Wallet.loadWallet({ name, path, storageType });

    let existingTx;
    if (txid) {
      existingTx = JSON.parse(await wallet.getTransactionByTxid({ txid }));
    } else if (rawtx) {
      existingTx = ethers.utils.serializeTransaction
    } else {
      throw new Error('Must provide either a raw transaction or transaction id.');
    }
    let newFee;
    if (gwei) {
      const wei = Number(gwei) * 1000000000;
      if (wei <= existingTx.gasPrice){
        throw new Error(`Provided gwei is not greater than existing tx gwei. Existing Tx Gwei: ${existingTx.gasPrice / 1000000000}`);
      }
      existingTx.gasPrice = wei;
      existingTx.fee = wei * existingTx.gasLimit;
    }
    const networkFeeRate = JSON.parse(await wallet.getNetworkFee()).feerate;
    if (['ETH','MATIC'].includes(wallet.chain) && gwei){
      if (gwei <= existingTx.gas) {
        throw new Error('Provided gwei is not greater than existing tx gwei.');
      } 
      existingTx.gas = gwei;
    }

    // if (['BTC', 'LTC', 'DOGE'].includes(wallet.chain)) {
    //   feeRate = satsPerByte;
    // }

    const tx = await wallet.newTx(existingTx);
    console.log('unsignedRawTx: ', tx);
    const passphrase = await promptly.password('Wallet Password:');
    wallet = await wallet.unlock(passphrase);
    const signedTx = await wallet.signTx({ tx, passphrase });
    console.log('signedRawTx: ', signedTx);
    const confirmed = await promptly.confirm('broadcast? (y/n)');
    if (!confirmed) {
      return;
    }
    //const transaction = await wallet.broadcast({ tx:signedTx });
    console.log('txid: ', transaction.txid);
    console.log('Transaction broadcasted');
  } catch (e) {
    console.error(e);
  }
};

function getCurrencies() {
  return new Promise((resolve, reject) => {
    https.get('https://bitpay.com/currencies', res => {
      if (res.statusCode !== 200) {
        reject(new Error('Request Failed'));
      }
      let data = '';
      res.on('data', (chunk) => {
        data += chunk;
      });
      res.on('end', () => resolve(data.toString()));
    });
  });
}

main();
